<%- include('../layouts/main', { 
    title: 'Viewer - ' + (volume.series ? volume.series.title : 'No Overflow'), 
    bodyClass: 'viewer-page',
    headerButtons: `
        <div class="page-nav-buttons">
            <a href="/library/series/${volume.series._id}/volume/${volume._id}" class="nav-button btn">
                Chapters <ion-icon size="large" name="library"></ion-icon>
            </a>
            <button id="load-prev-btn" class="nav-button btn">
                <ion-icon size="large" name="play-back"></ion-icon> Previous Page
            </button>
            <button id="load-next-btn" class="nav-button btn">
                Next Page <ion-icon size="large" name="play-forward"></ion-icon>
            </button>
            <button id="reload-page-btn" class="nav-button btn">
                Reload page <ion-icon size="large" name="reload-circle"></ion-icon>
            </button>
        </div>
    `,
    body: `
        <div class="scroll-wrapper" data-current-page="0" data-total-pages=""></div>
    `,
    extraScripts: `
        <script type="module">
            import { initPageManager } from "/services/public/PageManager.js";
            import { getLastVisitedPage, setLastVisitedPage } from "/libs/Utility.js";

            (async () => {
                const params = new URLSearchParams(window.location.search);
                const volumeId = "${volume._id}";
                let chapterNumber = params.get("chapter");

                // Default to Chapter 1 if not specified
                if (!chapterNumber) {
                    chapterNumber = "1";
                    const newUrl = new URL(window.location.href);
                    newUrl.searchParams.set("chapter", "1");
                    window.history.replaceState({ path: newUrl.href }, "", newUrl.href);
                }

                var chapter = await getChapterData(volumeId, chapterNumber);

                if (!chapter || !chapter.pages || chapter.pages.length === 0) {
                    document.getElementById('main-content').innerHTML = "<h1>Error: Chapter data or pages not found.</h1>";
                    return;
                }

                chapter.pages.sort((a, b) => a.index - b.index);

                const scrollWrapper = document.querySelector(".scroll-wrapper");
                if (!scrollWrapper) return;

                chapter.pages.forEach((page, index) => {
                    const section = document.createElement("section");
                    section.id = 'section-' + index;
                    section.classList.add('section-' + index, "scroll-section", "page-container");
                    scrollWrapper.appendChild(section);
                });

                document.addEventListener("view_visible", async (e) => {
                    if (!e.target.classList.contains('page-container')) return;
                    const currentPageIndex = e.detail.index;
                    const storageKey = volumeId + "_" + chapterNumber;
                    setLastVisitedPage(storageKey, currentPageIndex);
                    
                    if (!chapter.pages[currentPageIndex]) return;

                    const parts = chapter.pages[currentPageIndex].path.split("/");
                    const currentPageId = parts[parts.length - 2];
                    const pageNum = currentPageId.replace('page', '');

                    const newUrl = new URL(window.location.href);
                    newUrl.searchParams.set("page", pageNum);
                    window.history.replaceState({ path: newUrl.href }, "", newUrl.href);
                });

                const pages = chapter.pages.map((page, index) => ({
                    ...page,
                    html: page.path,
                    containerId: 'section-' + index,
                }));

                const pageManager = initPageManager(pages);

                document.getElementById("load-next-btn").addEventListener("click", async (e) => {
                    e.preventDefault();
                    const nextPageIndex = pageManager.currentPageIndex + 1;
                    if (nextPageIndex < pages.length) await pageManager.goToPage(nextPageIndex);
                });

                document.getElementById("load-prev-btn").addEventListener("click", async (e) => {
                    e.preventDefault();
                    const prevPageIndex = pageManager.currentPageIndex - 1;
                    if (prevPageIndex >= 0) await pageManager.goToPage(prevPageIndex);
                });

                document.getElementById("reload-page-btn").addEventListener("click", async (e) => {
                    e.preventDefault();
                    const currentPage = pages[pageManager.currentPageIndex];
                    if (!currentPage) return;

                    const parts = currentPage.html.split("/");
                    const pageId = parts[parts.length - 2];
                    const chapterId = parts[parts.length - 3];

                    try {
                        const res = await fetch('/api/editor/sync-page/' + volumeId + '/' + chapterId + '/' + pageId, { method: 'POST' });
                        if (res.status === 401) { window.location.href = '/login'; return; }
                        const result = await res.json();
                        if (result.ok && result.page) {
                            pages[pageManager.currentPageIndex] = {
                                ...pages[pageManager.currentPageIndex],
                                layoutId: result.page.layoutId,
                                mediaData: result.page.mediaData,
                                sceneData: result.page.sceneData
                            };
                        }
                    } catch (err) { console.error("Failed to sync page data:", err); }

                    window.audioStateManager.stopBackgroundAudio(0);
                    window.audioStateManager.stopDialogueAudio();
                    await pageManager.goToPage(pageManager.currentPageIndex);
                });

                let initialPageIndex = 0;
                const pageParam = params.get("page");

                if (pageParam) {
                    const foundIndex = chapter.pages.findIndex((p) => {
                        const parts = p.path.split("/");
                        const pageId = parts[parts.length - 2];
                        return pageId === pageParam || p.index.toString() === pageParam;
                    });
                    if (foundIndex !== -1) initialPageIndex = foundIndex;
                } else {
                    const lastPageIndex = getLastVisitedPage(chapterNumber);
                    if (lastPageIndex !== null) {
                        const pageIndex = parseInt(lastPageIndex, 10);
                        if (!isNaN(pageIndex) && pageIndex >= 0 && pageIndex < chapter.pages.length) initialPageIndex = pageIndex;
                    }
                }
                await pageManager.goToPage(initialPageIndex);
                window.dispatchEvent(new CustomEvent("sectionsloadedcomplete", { detail: "" }));
            })();

            const header = document.querySelector("header");
            let hideTimeout;
            document.addEventListener("mousemove", () => {
                header.classList.add("is-visible");
                document.body.classList.remove("cursor-hidden");
                clearTimeout(hideTimeout);
                hideTimeout = setTimeout(() => {
                    header.classList.remove("is-visible");
                    document.body.classList.add("cursor-hidden");
                }, 2000);
            });

            async function getChapterData(volumeId, chapterNumber) {
                try {
                    const res = await fetch('/api/volume/' + volumeId + '/chapter/' + chapterNumber);
                    if (res.status === 401) { window.location.href = '/login'; return; }
                    const data = await res.json();
                    if (!data.ok) return;
                    return data.view;
                } catch (err) { console.error("Error fetching chapter data:", err); return; }
            }

            document.addEventListener("keydown", (e) => {
                if (e.key === "ArrowRight") { e.preventDefault(); document.getElementById("load-next-btn").click(); }
                else if (e.key === "ArrowLeft") { e.preventDefault(); document.getElementById("load-prev-btn").click(); }
            });
        </script>
    `
}) %>
